/**
 * Forte Actions Â∑•‰ΩúÊµÅÊúçÂä°
 * ÂÆûÁé∞‰∏ä‰º† ‚Üí AIÁîüÊàê ‚Üí Ëá™Âä®Èì∏ÈÄ†ÁöÑËá™Âä®ÂåñÊµÅÁ®ã
 */

import aiService from './aiService.js';
import ipfsService from './ipfsService.js';
import MusicNFT from '../models/MusicNFT.js';
import User from '../models/User.js';
import { v4 as uuidv4 } from 'uuid';
import Database from '../config/database.js';

class ForteActionsService {
  /**
   * ÊâßË°åÂÆåÊï¥ÁöÑForte ActionsÂ∑•‰ΩúÊµÅ
   * @param {Object} params - Â∑•‰ΩúÊµÅÂèÇÊï∞
   * @param {string} params.userId - Áî®Êà∑ID
   * @param {string} params.prompt - AIÁîüÊàêÊèêÁ§∫ËØç
   * @param {Object} params.metadata - Èü≥‰πêÂÖÉÊï∞ÊçÆ
   * @param {Array} params.royalties - ÁâàÁ®éÈÖçÁΩÆ
   * @param {boolean} params.autoMint - ÊòØÂê¶Ëá™Âä®Èì∏ÈÄ†
   * @returns {Object} Â∑•‰ΩúÊµÅÊâßË°åÁªìÊûú
   */
  async executeWorkflow(params) {
    const {
      userId,
      prompt,
      metadata,
      royalties = [],
      autoMint = true
    } = params;

    try {
      console.log('üöÄ Starting Forte Actions workflow for user:', userId);
      
      // Ê≠•È™§1: È™åËØÅÁî®Êà∑
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // Ê≠•È™§2: AIÈü≥‰πêÁîüÊàê
      console.log('üéµ Step 1: Generating AI music...');
      const aiResult = await this.generateMusic({
        prompt,
        title: metadata.title,
        artist: metadata.artist,
        genre: metadata.genre,
        mood: metadata.mood,
        duration: metadata.duration || 30
      });

      // Ê≠•È™§3: ‰∏ä‰º†Âà∞IPFS
      console.log('üìÅ Step 2: Uploading to IPFS...');
      const ipfsResult = await this.uploadToIPFS({
        audioUrl: aiResult.audioUrl,
        coverImageUrl: aiResult.coverImageUrl,
        metadata: {
          ...metadata,
          prompt,
          aiModel: aiResult.aiModel,
          generatedAt: new Date().toISOString()
        },
        royalties
      });

      // Ê≠•È™§4: Ëá™Âä®Èì∏ÈÄ†NFT (Â¶ÇÊûúÂêØÁî®)
      let mintResult = null;
      if (autoMint) {
        console.log('‚õèÔ∏è Step 3: Auto-minting NFT...');
        mintResult = await this.autoMintNFT({
          userId,
          ipfsMetadata: ipfsResult.nftMetadata,
          royalties
        });
      }

      // Ê≠•È™§5: ‰øùÂ≠òÂ∑•‰ΩúÊµÅËÆ∞ÂΩï
      const workflowRecord = await this.saveWorkflowRecord({
        userId,
        prompt,
        aiResult,
        ipfsResult,
        mintResult,
        status: autoMint ? 'completed' : 'pending_mint',
        completedAt: new Date()
      });

      console.log('‚úÖ Forte Actions workflow completed successfully');

      return {
        success: true,
        workflowId: workflowRecord.id,
        steps: {
          aiGeneration: aiResult,
          ipfsUpload: ipfsResult,
          nftMinting: mintResult
        },
        status: autoMint ? 'completed' : 'pending_mint',
        message: autoMint 
          ? 'Workflow completed successfully with auto-minting'
          : 'Workflow completed, ready for manual minting'
      };

    } catch (error) {
      console.error('‚ùå Forte Actions workflow failed:', error);
      
      // ‰øùÂ≠òÂ§±Ë¥•ËÆ∞ÂΩï
      await this.saveWorkflowRecord({
        userId,
        prompt,
        status: 'failed',
        error: error.message,
        failedAt: new Date()
      });

      throw error;
    }
  }

  /**
   * AIÈü≥‰πêÁîüÊàêÊ≠•È™§
   */
  async generateMusic(params) {
    const {
      prompt,
      title,
      artist,
      genre,
      mood,
      duration
    } = params;

    try {
      // ‰ΩøÁî®AIÊúçÂä°ÁîüÊàêÈü≥‰πê
      const musicResult = await aiService.generateMusic({
        prompt,
        duration,
        model: 'musicgen-stereo-large'
      });

      // ÁîüÊàêÂ∞ÅÈù¢Âõæ
      const coverResult = await aiService.generateCoverImage({
        prompt: `Album cover for "${title}" by ${artist}, ${genre} music, ${mood} mood`,
        style: 'digital art'
      });

      return {
        audioUrl: musicResult.audioUrl,
        coverImageUrl: coverResult.imageUrl,
        aiModel: musicResult.model,
        generationTime: musicResult.generationTime,
        metadata: {
          title,
          artist,
          genre,
          mood,
          duration,
          prompt
        }
      };

    } catch (error) {
      console.error('AI generation failed:', error);
      throw new Error(`AI music generation failed: ${error.message}`);
    }
  }

  /**
   * IPFS‰∏ä‰º†Ê≠•È™§
   */
  async uploadToIPFS(params) {
    const {
      audioUrl,
      coverImageUrl,
      metadata,
      royalties
    } = params;

    try {
      // ‰∏ä‰º†Èü≥È¢ëÊñá‰ª∂
      const audioUpload = await ipfsService.uploadFromUrl(audioUrl, {
        filename: `${metadata.title.replace(/\s+/g, '_')}.mp3`,
        type: 'audio'
      });

      // ‰∏ä‰º†Â∞ÅÈù¢ÂõæÁâá
      const coverUpload = await ipfsService.uploadFromUrl(coverImageUrl, {
        filename: `${metadata.title.replace(/\s+/g, '_')}_cover.jpg`,
        type: 'image'
      });

      // ÂàõÂª∫NFTÂÖÉÊï∞ÊçÆ
      const nftMetadata = {
        title: metadata.title,
        artist: metadata.artist,
        description: metadata.description || `AI-generated ${metadata.genre} music`,
        audioURL: `ipfs://${audioUpload.hash}`,
        coverImageURL: `ipfs://${coverUpload.hash}`,
        genre: metadata.genre,
        mood: metadata.mood,
        duration: metadata.duration,
        prompt: metadata.prompt,
        aiModel: metadata.aiModel,
        generatedAt: metadata.generatedAt,
        royalties: royalties.map(r => ({
          recipient: r.recipient,
          percentage: r.percentage,
          description: r.description
        })),
        attributes: [
          { trait_type: "Genre", value: metadata.genre },
          { trait_type: "Mood", value: metadata.mood },
          { trait_type: "Duration", value: `${metadata.duration}s` },
          { trait_type: "AI Model", value: metadata.aiModel },
          { trait_type: "Generation Type", value: "AI Generated" }
        ]
      };

      // ‰∏ä‰º†ÂÖÉÊï∞ÊçÆ
      const metadataUpload = await ipfsService.uploadJSON(nftMetadata, {
        filename: `${metadata.title.replace(/\s+/g, '_')}_metadata.json`
      });

      return {
        audio: audioUpload,
        cover: coverUpload,
        metadata: metadataUpload,
        nftMetadata
      };

    } catch (error) {
      console.error('IPFS upload failed:', error);
      throw new Error(`IPFS upload failed: ${error.message}`);
    }
  }

  /**
   * Ëá™Âä®Èì∏ÈÄ†NFTÊ≠•È™§
   */
  async autoMintNFT(params) {
    const {
      userId,
      ipfsMetadata,
      royalties
    } = params;

    try {
      // Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØ
      const user = await User.findById(userId);
      if (!user) {
        throw new Error('User not found');
      }

      // ‰ΩøÁî®FlowÈí±ÂåÖÂú∞ÂùÄÊàñÈªòËÆ§Âú∞ÂùÄ
      const recipientAddress = user.flowWallet?.address || user.address || process.env.FLOW_ADDRESS;
      if (!recipientAddress) {
        throw new Error('No Flow address found for user');
      }

      console.log(`üîó Minting NFT for user ${user.username} at address ${recipientAddress}`);

      // ‰ΩøÁî®FlowÊúçÂä°ËøõË°åÁúüÊ≠£ÁöÑNFTÈì∏ÈÄ†
      const flowService = (await import('./flowService.js')).default;
      
      const mintParams = {
        recipient: recipientAddress,
        title: ipfsMetadata.title || 'Untitled Music',
        description: ipfsMetadata.description || 'AI Generated Music NFT',
        audioHash: ipfsMetadata.audioHash || '',
        coverImageHash: ipfsMetadata.coverImageHash || '',
        metadataHash: ipfsMetadata.metadataHash || '',
        royalties: royalties.map(r => ({
          recipient: r.recipient || recipientAddress,
          percentage: r.percentage || 0
        }))
      };

      const mintResult = await flowService.mintMusicNFT(mintParams);

      if (!mintResult.success) {
        throw new Error('NFT minting failed on Flow blockchain');
      }

      // ‰øùÂ≠òNFTËÆ∞ÂΩïÂà∞Êï∞ÊçÆÂ∫ì
      const nftRecord = new MusicNFT({
        title: ipfsMetadata.title,
        description: ipfsMetadata.description,
        creator: recipientAddress,
        owner: recipientAddress,
        music: {
          duration: ipfsMetadata.duration || 0,
          genre: ipfsMetadata.genre || 'AI Generated'
        },
        files: {
          audio: {
            url: ipfsMetadata.audioURL,
            ipfsHash: ipfsMetadata.audioHash || ''
          },
          cover: {
            url: ipfsMetadata.coverImageURL,
            ipfsHash: ipfsMetadata.coverImageHash || ''
          },
          metadata: {
            url: ipfsMetadata.metadataURL || '',
            ipfsHash: ipfsMetadata.metadataHash || ''
          }
        },
        blockchain: {
          tokenId: mintResult.tokenId,
          contractAddress: process.env.MUSIC_NFT_CONTRACT_ADDRESS || 'MusicNFT',
          transactionHash: mintResult.transactionId,
          blockNumber: mintResult.blockHeight,
          mintedAt: new Date(),
          network: 'flow'
        },
        royalties: royalties,
        status: 'minted'
      });

      // Save the NFT record
      await nftRecord.save();

      console.log(`‚úÖ NFT record saved: ${nftRecord.id}`);

      return {
        tokenId: mintResult.tokenId,
        transactionHash: mintResult.transactionId,
        transactionId: mintResult.transactionId,
        nftId: nftRecord.id,
        contractAddress: process.env.MUSIC_NFT_CONTRACT_ADDRESS || 'MusicNFT',
        gasUsed: mintResult.gasUsed,
        blockHeight: mintResult.blockHeight,
        status: 'success',
        isMock: mintResult.isMock || false
      };

    } catch (error) {
      console.error('Auto-minting failed:', error);
      throw new Error(`Auto-minting failed: ${error.message}`);
    }
  }

  /**
   * ‰øùÂ≠òÂ∑•‰ΩúÊµÅËÆ∞ÂΩï
   */
  async saveWorkflowRecord(params) {
    const {
      userId,
      prompt,
      aiResult,
      ipfsResult,
      mintResult,
      status,
      error,
      completedAt,
      failedAt
    } = params;

    try {
      // ËøôÈáåÂèØ‰ª•‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ìÊàñÊó•ÂøóÁ≥ªÁªü
      const workflowRecord = {
        id: `workflow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        userId,
        prompt,
        steps: {
          aiGeneration: aiResult || null,
          ipfsUpload: ipfsResult || null,
          nftMinting: mintResult || null
        },
        status,
        error: error || null,
        createdAt: new Date(),
        completedAt: completedAt || null,
        failedAt: failedAt || null
      };

      // ‰øùÂ≠òÂà∞RedisÊàñÂÖ∂‰ªñÂ≠òÂÇ®
      console.log('üíæ Saving workflow record:', workflowRecord.id);
      
      return workflowRecord;

    } catch (error) {
      console.error('Failed to save workflow record:', error);
      throw error;
    }
  }

  /**
   * Ëé∑ÂèñÂ∑•‰ΩúÊµÅÁä∂ÊÄÅ
   */
  async getWorkflowStatus(workflowId) {
    try {
      // ‰ªéÂ≠òÂÇ®‰∏≠Ëé∑ÂèñÂ∑•‰ΩúÊµÅËÆ∞ÂΩï
      // ËøôÈáåÂèØ‰ª•‰ªéRedisÊàñÊï∞ÊçÆÂ∫ìÊü•ËØ¢
      console.log('üìä Getting workflow status for:', workflowId);
      
      return {
        workflowId,
        status: 'completed', // Á§∫‰æãÁä∂ÊÄÅ
        steps: {
          aiGeneration: { status: 'completed', completedAt: new Date() },
          ipfsUpload: { status: 'completed', completedAt: new Date() },
          nftMinting: { status: 'completed', completedAt: new Date() }
        }
      };

    } catch (error) {
      console.error('Failed to get workflow status:', error);
      throw error;
    }
  }

  /**
   * ÊâπÈáèÊâßË°åÂ∑•‰ΩúÊµÅ
   */
  async executeBatchWorkflow(batchParams) {
    const results = [];
    
    for (const params of batchParams) {
      try {
        const result = await this.executeWorkflow(params);
        results.push({
          success: true,
          ...result
        });
      } catch (error) {
        results.push({
          success: false,
          error: error.message,
          params
        });
      }
    }

    return {
      total: batchParams.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      results
    };
  }
}

export default new ForteActionsService();