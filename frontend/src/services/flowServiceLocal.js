/**
 * FlowService Local - Local simulation version
 * For demo purposes, no network connection required
 */

class FlowServiceLocal {
  constructor() {
    this.isInitialized = true;
    this.currentUser = { 
      loggedIn: false, 
      addr: null,
      cid: null 
    };
    this.mockNFTs = [
      {
        id: '1',
        title: 'Electronic Dreams',
        artist: 'AI Composer',
        description: 'A futuristic electronic composition generated by AI',
        audioUrl: '/demo-audio/electronic-dreams.mp3',
        coverImage: '/demo-images/electronic-dreams.jpg',
        price: '10.5',
        currency: 'FLOW',
        owner: '0x1234567890abcdef',
        royalties: [
          { recipient: '0x1234567890abcdef', percentage: 10 }
        ],
        metadata: {
          genre: 'Electronic',
          duration: '3:45',
          bpm: 128,
          key: 'C Major'
        }
      },
      {
        id: '2',
        title: 'Ambient Serenity',
        artist: 'Digital Harmony',
        description: 'Peaceful ambient sounds for relaxation',
        audioUrl: '/demo-audio/ambient-serenity.mp3',
        coverImage: '/demo-images/ambient-serenity.jpg',
        price: '8.0',
        currency: 'FLOW',
        owner: '0xabcdef1234567890',
        royalties: [
          { recipient: '0xabcdef1234567890', percentage: 15 }
        ],
        metadata: {
          genre: 'Ambient',
          duration: '5:20',
          bpm: 60,
          key: 'A Minor'
        }
      },
      {
        id: '3',
        title: 'Jazz Fusion',
        artist: 'AI Jazz Ensemble',
        description: 'Modern jazz fusion with AI-generated improvisation',
        audioUrl: '/demo-audio/jazz-fusion.mp3',
        coverImage: '/demo-images/jazz-fusion.jpg',
        price: '15.0',
        currency: 'FLOW',
        owner: '0x9876543210fedcba',
        royalties: [
          { recipient: '0x9876543210fedcba', percentage: 12 }
        ],
        metadata: {
          genre: 'Jazz',
          duration: '4:30',
          bpm: 140,
          key: 'Bb Major'
        }
      }
    ];
    this.mockWalletAddress = '0x1234567890abcdef';
    this.mockBalance = '125.75';
  }

  // Initialize service
  async init() {
    console.log('ðŸ  FlowService Local initialized (Demo Mode)');
    return true;
  }

  // Simulate user authentication
  async authenticate() {
    console.log('ðŸ” Simulating wallet authentication...');
    
    // Simulate authentication delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.currentUser = {
      loggedIn: true,
      addr: this.mockWalletAddress,
      cid: 'demo-user-cid'
    };

    console.log('âœ… Mock authentication successful');
    return this.currentUser;
  }

  // Simulate user logout
  async unauthenticate() {
    console.log('ðŸšª Simulating wallet logout...');
    this.currentUser = { loggedIn: false, addr: null, cid: null };
    return this.currentUser;
  }

  // Get current user
  getCurrentUser() {
    return this.currentUser;
  }

  // Get user balance
  async getBalance(address = null) {
    console.log('ðŸ’° Getting mock balance...');
    return {
      balance: this.mockBalance,
      currency: 'FLOW'
    };
  }

  // Get NFT list
  async getNFTs(address = null) {
    console.log('ðŸŽµ Getting mock NFTs...');
    return this.mockNFTs;
  }

  // Get single NFT
  async getNFT(tokenId) {
    console.log(`ðŸŽµ Getting mock NFT: ${tokenId}`);
    return this.mockNFTs.find(nft => nft.id === tokenId) || null;
  }

  // Simulate NFT minting
  async mintNFT(metadata) {
    console.log('ðŸ”¨ Simulating NFT minting...');
    
    // Simulate minting delay
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const newNFT = {
      id: String(this.mockNFTs.length + 1),
      title: metadata.title || 'Untitled',
      artist: metadata.artist || 'Unknown Artist',
      description: metadata.description || 'No description',
      audioUrl: metadata.audioUrl || '/demo-audio/placeholder.mp3',
      coverImage: metadata.coverImage || '/demo-images/placeholder.jpg',
      price: metadata.price || '0',
      currency: 'FLOW',
      owner: this.mockWalletAddress,
      royalties: metadata.royalties || [],
      metadata: metadata.metadata || {}
    };

    this.mockNFTs.push(newNFT);
    console.log('âœ… Mock NFT minted successfully');
    return {
      success: true,
      tokenId: newNFT.id,
      transactionId: `mock-tx-${Date.now()}`,
      nft: newNFT
    };
  }

  // Simulate NFT purchase
  async purchaseNFT(tokenId, price) {
    console.log(`ðŸ’³ Simulating NFT purchase: ${tokenId} for ${price} FLOW`);
    
    // Simulate purchase delay
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const nft = this.mockNFTs.find(nft => nft.id === tokenId);
    if (!nft) {
      throw new Error('NFT not found');
    }

    // Update owner
    nft.owner = this.mockWalletAddress;
    
    console.log('âœ… Mock NFT purchase successful');
    return {
      success: true,
      transactionId: `mock-purchase-tx-${Date.now()}`,
      nft: nft
    };
  }

  // Simulate transfer
  async transfer(to, amount) {
    console.log(`ðŸ’¸ Simulating transfer: ${amount} FLOW to ${to}`);
    
    // Simulate transfer delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    console.log('âœ… Mock transfer successful');
    return {
      success: true,
      transactionId: `mock-transfer-tx-${Date.now()}`,
      from: this.mockWalletAddress,
      to: to,
      amount: amount
    };
  }

  // Simulate network status
  async getNetworkStatus() {
    return {
      connected: true,
      network: 'local-demo',
      blockHeight: Math.floor(Math.random() * 1000000) + 5000000,
      status: 'healthy'
    };
  }

  // Simulate connection test
  async testConnection() {
    console.log('ðŸ” Testing mock connection...');
    await new Promise(resolve => setTimeout(resolve, 500));
    console.log('âœ… Mock connection test successful');
    return true;
  }

  // Check if initialized
  isReady() {
    return this.isInitialized;
  }

  // Get service status
  getStatus() {
    return {
      initialized: this.isInitialized,
      connected: true,
      mode: 'local-demo',
      user: this.currentUser
    };
  }
}

// Create singleton instance
let flowServiceLocalInstance = null;

export const getFlowServiceLocal = () => {
  if (!flowServiceLocalInstance) {
    flowServiceLocalInstance = new FlowServiceLocal();
  }
  return flowServiceLocalInstance;
};

export default getFlowServiceLocal();